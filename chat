import React, { useState, useEffect, useRef } from 'react';

// --- Variáveis Globais OBRIGATÓRIAS do Canvas ---
// A chave e a URL da API do Gemini são necessárias
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
const API_KEY = "AIzaSyA536J-fUKm26IYCwNqCggEJ9JCwj-glNc"; // A chave será fornecida pelo Canvas

// Componente principal do Chat
const App = () => {
    // 1. Estado para mensagens (usa localStorage para persistência simples)
    const [messages, setMessages] = useState(() => {
        const savedMessages = localStorage.getItem('gemini_simple_chat_history');
        return savedMessages ? JSON.parse(savedMessages) : [];
    });
    
    const [newMessage, setNewMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef(null);
    
    // ID de Usuário Fictício (apenas para exibição, não para autenticação)
    const userId = "CONVIDADO"; 

    // Efeito para salvar o histórico no localStorage
    useEffect(() => {
        localStorage.setItem('gemini_simple_chat_history', JSON.stringify(messages));
    }, [messages]);

    // Auto-scroll para a mensagem mais recente
    useEffect(() => {
        if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
    }, [messages]);

    // 4. Lógica de Envio de Mensagem
    const handleSendMessage = async (e) => {
        e.preventDefault();
        const text = newMessage.trim();
        if (!text || isLoading) return;

        setIsLoading(true);
        setNewMessage('');

        // 4a. Salva a mensagem do usuário no estado local
        const userMessage = {
            role: 'user',
            text: text,
            timestamp: new Date().toISOString(),
        };
        
        // Adiciona a mensagem do usuário imediatamente
        const updatedMessages = [...messages, userMessage];
        setMessages(updatedMessages);

        await generateResponse(text, updatedMessages);
    };

    // 5. Lógica para Gerar Resposta da IA (Gemini)
    const generateResponse = async (userText, currentHistory) => {
        // Mapeia o histórico atual para o formato da API
        const chatHistory = currentHistory
            .filter(m => m.text)
            .map(m => ({
                role: m.role,
                parts: [{ text: m.text }]
            }));
        
        const systemPrompt = `Você é o "Chat Inteligente" do Gemini, um assistente prestativo e conversacional. Responda de forma clara, amigável e use emojis. Mantenha o contexto das conversas anteriores. Responda em Português do Brasil.`;

        const payload = {
            contents: chatHistory,
            systemInstruction: { parts: [{ text: systemPrompt }] }
        };

        const url = `${GEMINI_API_URL}?key=${API_KEY}`;
        let response;
        
        try {
            // Implementação de Backoff Exponencial
            const maxRetries = 3;
            let currentDelay = 1000;

            for (let i = 0; i < maxRetries; i++) {
                response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break;
                }

                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, currentDelay));
                    currentDelay *= 2;
                } else {
                    throw new Error(`Erro na API: ${response.status}`);
                }
            }
            
            if (!response || !response.ok) {
                throw new Error("Falha na chamada da API após todas as retentativas.");
            }

            const result = await response.json();
            const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text || "Desculpe, não consegui gerar uma resposta.";

            // 5a. Salva a resposta da IA no estado local
            const geminiMessage = {
                role: 'gemini',
                text: generatedText,
                timestamp: new Date().toISOString(),
            };
            setMessages(prev => [...prev, geminiMessage]);

        } catch (error) {
            console.error("Erro na chamada da API do Gemini:", error);
            const errorMessage = "Não foi possível conectar ao Gemini. Verifique sua chave API ou o console.";
            setMessages(prev => [...prev, {
                role: 'gemini',
                text: errorMessage,
                timestamp: new Date().toISOString(),
            }]);
        } finally {
            setIsLoading(false);
        }
    };

    // 6. Componentes de UI
    const ChatBubble = ({ message }) => {
        const isUser = message.role === 'user';
        // Formata o texto para quebras de linha
        const formattedText = message.text ? message.text.split('\n').map((item, key) => {
            return <React.Fragment key={key}>{item}<br/></React.Fragment>
        }) : "Mensagem vazia";

        return (
            <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
                <div className={`max-w-xs md:max-w-md lg:max-w-xl p-3 rounded-xl shadow-md ${isUser ? 'bg-blue-500 text-white rounded-br-none' : 'bg-gray-200 text-gray-800 rounded-tl-none'}`}>
                    {formattedText}
                </div>
            </div>
        );
    };

    return (
        <div className="flex flex-col h-screen bg-gray-100">
            {/* Header */}
            <header className="bg-white p-4 shadow-md flex justify-between items-center fixed top-0 left-0 right-0 z-10 w-full lg:max-w-3xl lg:mx-auto">
                <h1 className="text-lg font-bold text-gray-800 flex items-center">
                    <svg className="w-6 h-6 mr-2 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M2 5a2 2 0 012-2h12a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2V5zm4 3a2 2 0 100-4 2 2 0 000 4zm8 0a2 2 0 100-4 2 2 0 000 4z" />
                    </svg>
                    Chat Simples Gemini
                </h1>
                <span className="text-xs text-gray-500">Usuário: {userId}</span>
            </header>

            {/* Chat Body */}
            <main className="flex-1 overflow-y-auto p-4 pt-16 pb-20 space-y-2 lg:pt-20 lg:pb-24 max-w-3xl w-full mx-auto">
                {messages.length === 0 && (
                    <div className="text-center text-gray-500 mt-10 p-4 bg-white rounded-lg shadow-sm">
                        <p>Inicie sua conversa! O histórico será salvo temporariamente no seu navegador.</p>
                    </div>
                )}
                
                {messages.map((msg, index) => (
                    <ChatBubble key={index} message={msg} />
                ))}

                {isLoading && (
                     <div className="flex justify-start mb-4">
                        <div className="max-w-xs md:max-w-md lg:max-w-xl p-3 rounded-xl shadow-md bg-gray-200 text-gray-800 rounded-tl-none">
                            <div className="flex items-center space-x-1">
                                {/* Animação de digitação (dots) */}
                                <span className="dot-pulse w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                                <span className="dot-pulse w-2 h-2 rounded-full bg-blue-500 animate-pulse delay-75"></span>
                                <span className="dot-pulse w-2 h-2 rounded-full bg-blue-500 animate-pulse delay-150"></span>
                                <span className="text-sm ml-2">Digitando...</span>
                            </div>
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </main>

            {/* Input Footer */}
            <footer className="bg-white p-3 shadow-t fixed bottom-0 left-0 right-0 z-10 w-full lg:max-w-3xl lg:mx-auto">
                <form onSubmit={handleSendMessage} className="flex space-x-3">
                    <input
                        type="text"
                        value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        placeholder="Digite sua mensagem..."
                        className="flex-1 p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-150"
                        disabled={isLoading}
                    />
                    <button
                        type="submit"
                        className={`p-3 rounded-full text-white transition duration-150 ${isLoading || !newMessage.trim() ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}`}
                        disabled={isLoading || !newMessage.trim()}
                    >
                        <svg className="w-6 h-6 transform rotate-90" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 00.183.189l4 2A1 1 0 009 19.5h2a1 1 0 00.555-.164l4-2a1 1 0 00.183-.189l-7-14z" />
                        </svg>
                    </button>
                </form>
            </footer>

            {/* CSS para o efeito "Digitando..." (dot-pulse simplificado para React) */}
            <style jsx global>{`
                .dot-pulse {
                    animation: pulse 1s infinite;
                }
                @keyframes pulse {
                    0%, 100% { opacity: 0.2; }
                    50% { opacity: 1; }
                }
                .dot-pulse.delay-75 { animation-delay: 0.1s; }
                .dot-pulse.delay-150 { animation-delay: 0.2s; }
            `}</style>
        </div>
    );
};

export default App;
